package SpellChecker;

import Corpus.Sentence;
import Dictionary.TxtWord;
import Dictionary.Word;
import MorphologicalAnalysis.FsmMorphologicalAnalyzer;
import Ngram.NGram;
import Util.FileUtils;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.ArrayDeque;
import java.util.ArrayList;

public class TrieBasedSpellChecker extends NGramSpellChecker {

    private ArrayList<String> generatedWords;
    private Trie trie;

    /**
     * A constructor of {@link TrieBasedSpellChecker} class which takes a {@link FsmMorphologicalAnalyzer}, an {@link NGram}
     * and a {@link SpellCheckerParameter} as inputs. Then, calls its super class {@link NGramSpellChecker} with given inputs.
     *
     * @param fsm       {@link FsmMorphologicalAnalyzer} type input.
     * @param nGram     {@link NGram} type input.
     * @param parameter {@link SpellCheckerParameter} type input.
     */
    public TrieBasedSpellChecker(FsmMorphologicalAnalyzer fsm, NGram<String> nGram, SpellCheckerParameter parameter) {
        super(fsm, nGram, parameter);
        prepareTrie();
    }

    /**
     * {@inheritDoc}
     * This method also loads generated words from a file.
     */
    @Override
    protected void loadDictionaries() {
        super.loadDictionaries();
        String line;
        generatedWords = new ArrayList<>();
        try {
            BufferedReader trieReader = new BufferedReader(new InputStreamReader(FileUtils.getInputStream("generated_words.txt"), StandardCharsets.UTF_8));
            while ((line = trieReader.readLine()) != null) {
                generatedWords.add(line);
            }
            trieReader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Populates a Trie data structure with a set of strings generated by the morphological analyzer.
     *
     * @see Trie
     * @see FsmMorphologicalAnalyzer#generateAllParses(TxtWord, int)
     */
    private void prepareTrie() {
        trie = new Trie();
        for (String word : generatedWords) {
            trie.insert(word);
        }
    }

    /**
     * Checks if the trie object contains the candidate.
     * If it does, it compares the penalty of the candidate in the results with the penalty of the candidate variable.
     * If the current penalty of the candidate in the results is less than or equal to the current penalty
     * of the candidate variable, it removes the first element of the candidates ArrayDeque.
     * If not, it adds the candidate variable to the results ArrayList and removes the first element.
     * If the trie object does not contain the candidate, it checks if the current penalty and the current
     * index of the candidate variable and if they are not at the limit,
     * it moves the index one character to the right and generates new candidates.
     *
     * @param word     the word to search for candidates for
     * @param sentence the sentence containing the word
     * @return an ArrayList of Candidate objects representing the potential candidates
     */
    @Override
    protected ArrayList<Candidate> candidateList(Word word, Sentence sentence) {
        TrieCandidate candidate;
        ArrayDeque<TrieCandidate> candidates = new ArrayDeque<>();
        ArrayList<TrieCandidate> results = new ArrayList<>();
        candidates.addFirst(new TrieCandidate(word.getName(), -1, 0));
        String candidateName;
        double penaltyLimit = Math.min(word.charCount() / 2.0, 3.0);
        while (candidates.size() > 0) {
            candidate = candidates.peekFirst();
            candidateName = candidate.getName();
            if (trie.search(candidateName)) {
                if ((results.contains(candidate)) && (results.get(results.indexOf(candidate)).getCurrentPenalty() <= candidate.getCurrentPenalty())) {
                    candidates.removeFirst();
                } else {
                    results.add(candidates.removeFirst());
                }
            } else {
                if (candidate.getCurrentPenalty() > penaltyLimit - 1 || candidate.getCurrentIndex() >= candidateName.length() - 1) {
                    candidates.removeFirst();
                } else {
                    candidate = candidates.removeFirst();
                    candidate.nextIndex();
                    candidates.addLast(new TrieCandidate(candidate.getName(), candidate.getCurrentIndex(), candidate.getCurrentPenalty()));
                    ArrayList<TrieCandidate> newCandidates = generateTrieCandidates(candidate);
                    candidates.addAll(newCandidates);
                }
            }
        }
        return new ArrayList<Candidate>(results);
    }

    /**
     * Generates a set of candidates based on a given TrieCandidate.
     * The generated candidates are created by applying a set of operations to
     * the input TrieCandidate. The possible operations are:
     * De-asciification: replacing certain ASCII characters with their non-ASCII counterparts.
     * Substitution: replacing a single character with another character.
     * Insertion: adding a single character to the string.
     * Deletion: removing a single character from the string.
     * Transposition: swapping the positions of two adjacent characters in the string.
     *
     * @param candidate the input TrieCandidate
     * @return a set of candidate strings, each contained in a TrieCandidate object
     */
    private ArrayList <TrieCandidate> generateTrieCandidates(TrieCandidate candidate) {
        ArrayList<TrieCandidate> candidates = new ArrayList<TrieCandidate>();
        String currentName = candidate.getName();
        int currentIndex = candidate.getCurrentIndex();
        double currentPenalty = candidate.getCurrentPenalty();
        char[] deasciified = currentName.toCharArray();
        String letters;
        TrieNode currentNode = trie.getTrieNode(currentName.substring(0, currentIndex));
        if (currentNode == null) {
            return candidates;
        }
        letters = currentNode.childrenToString();
        switch (currentName.charAt(currentIndex)) {
            case 'c':
                deasciified[currentIndex] = 'ç';
                break;
            case 'g':
                deasciified[currentIndex] = 'ğ';
                break;
            case 'i':
                deasciified[currentIndex] = 'ı';
                break;
            case 's':
                deasciified[currentIndex] = 'ş';
                break;
            case 'o':
                deasciified[currentIndex] = 'ö';
                break;
            case 'u':
                deasciified[currentIndex] = 'ü';
                break;
        }
        String deasciifiedWord = new String(deasciified);
        if (!deasciifiedWord.equals(currentName) && trie.startsWith(deasciifiedWord.substring(0, currentIndex + 1))) {
            candidates.add(new TrieCandidate(deasciifiedWord, currentIndex, currentPenalty + 0.2));
        }
        for (int j = 0; j < letters.length(); j++) {
            String replaced = currentName.substring(0, currentIndex) + letters.charAt(j) + currentName.substring(currentIndex + 1);
            candidates.add(new TrieCandidate(replaced, currentIndex, currentPenalty + 1));
            String added = currentName.substring(0, currentIndex) + letters.charAt(j) + currentName.substring(currentIndex);
            candidates.add(new TrieCandidate(added, currentIndex, currentPenalty + 1));
            String addedLast = currentName + letters.charAt(j);
            if (trie.startsWith(addedLast)) {
                candidates.add(new TrieCandidate(addedLast, currentIndex, currentPenalty + 1));
            }
        }
        String deleted = currentName.substring(0, currentIndex) + currentName.substring(currentIndex + 1);
        if (deleted.length() > 1) {
            candidates.add(new TrieCandidate(deleted, currentIndex - 1, currentPenalty + 1));
        }
        if (currentIndex < currentName.length() - 1 && currentName.charAt(currentIndex) != currentName.charAt(currentIndex + 1) && trie.startsWith(currentName.substring(0, currentIndex + 2))) {
            String swapped = currentName.substring(0, currentIndex) + currentName.charAt(currentIndex + 1) + currentName.charAt(currentIndex) + currentName.substring(currentIndex + 2);
            candidates.add(new TrieCandidate(swapped, currentIndex, currentPenalty + 1));
        }
        return candidates;
    }
}
